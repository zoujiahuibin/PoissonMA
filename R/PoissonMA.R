#Poisson model averaging
#' @title PoissonMA: Model averaging method for Poisson regressions
#' @description
#' PoissonMA() is a function to realize model averaging method for Poisson regressions.
#'
#' @param y a vector consist of natural numbers.
#' @param X a numeric matrix.
#' @param Index NULL or an index matrix generated by ModelSetup(). Index will be calculate by ModelSetup() when Index=NULL.
#' If Index is assigned, modeltype and intercept are needless.
#' @param modeltype a string chose from 'nested' or 'all'. 'nested' means
#' generating candidate models in nested from according to cor(y,x); 'all' means considering
#' all possible combinations.
#' @param intercept a bool. It means the first column of X is 1, or not.
#'
#' @return a list contains model-averaging weight, optimal model index of AIC, BIC; MSE of MA, AIC, BIC, SAIC, SBIC, Full;
#' KL loss of MA, AIC, BIC, SAIC, SBIC, Full.
#' @export
#'
#' @import magrittr
#' @import Rsolnp
#' @import mvtnorm
#' @importFrom stats AIC BIC cor glm poisson
#' @importFrom utils combn
#'
#' @examples
#' library(mvtnorm)
#' library(magrittr)
#' library(Rsolnp)
#' beta0=rep(0.1,5)
#' X=rmvnorm(100,mean=rep(0,5))
#' lambda=exp(X%*%beta0)
#' y=rpois(100,lambda)
#' PoissonMA(y,X, modeltype='nested',intercept=FALSE)
#'
#'
#  beta0=rep(0.5,5)
#' X=cbind(1,rmvnorm(100,mean=rep(0,4)))
#' lambda=exp(X%*%beta0)
#' y=rpois(100,lambda)
#' PoissonMA(y,X, modeltype='nested',intercept=TRUE)
#'
#'
#'

PoissonMA<-function(y,X,Index=NULL, modeltype,intercept){
  #setup candidate models
  if(is.null(Index)){
    Index=ModelSetup(y,X,modeltype=modeltype,intercept)
  }
  S=nrow(Index)
  p2=ncol(Index)
  n=length(y)


  # solve every candidate model
  modelsolver<-function(i){
    datai=data.frame(cbind(y,X[,Index[i,]]))
    set.seed(100)
    fit <- try(
      modeli<-glm(y~.-1,family = poisson(link = "log"),data=datai)#,control=list(maxit=maxit))
    )
    if("try-error" %in% class(fit)){
      print(paste0("error in solving candidate models s=",i))
      hatbetai=rep(0,p2)
      Bic=1e7
      Aic=1e7

    }else if(!modeli$converged){
      print(paste0("disconvergent in solving candidate model s=",i))
      hatbetai=rep(0,p2)
      hatbetai[c(Index[i,])]=modeli$coefficients
      hatbetai[is.na(hatbetai)]=0
      Bic=BIC(modeli)
      Aic=AIC(modeli)
    }else{
      hatbetai=rep(0,p2)
      hatbetai[c(Index[i,])]=modeli$coefficients
      hatbetai[is.na(hatbetai)]=0
      Bic=BIC(modeli)
      Aic=AIC(modeli)
    }
    return(list(hatbetai,Aic,Bic))

  }

  Aic=matrix(ncol=1,nrow = S)
  Bic=Aic
  Hatbeta=matrix(nrow = S,ncol=p2)
  for (i in 1:S) {
    parlresult=modelsolver(i)
    Hatbeta[i,]=parlresult[[1]]
    Aic[i]=parlresult[[2]]
    Bic[i]=parlresult[[3]]
  }
  rm(i,parlresult)



  # calculate \sum_{i=1}^n y_i x_i^T \hatbeta_{(s)}^{(y_i-1)}, remark1
  Yxbetersolver<-function(s){
    yxbeta=0
    for (i in 1:n) {
      if(y[i]!=0){
        yi=y
        yi[i]=yi[i]-1
        datai=data.frame(cbind(y=yi,X[,Index[s,]]))
        fit<-try(
          modeli<-glm(y~.-1,family = poisson(link = "log"),data=datai)
        )
        if("try-error" %in% class(fit)){
          hatbetai=rep(0,length(Index[s,]))
        }else if(!modeli$converged){
          hatbetai=rep(0,length(modeli$coefficients))
          hatbetai[is.na(hatbetai)]=0
          # print("not converge！")
        }else{
          hatbetai=modeli$coefficients
          hatbetai[is.na(hatbetai)]=0
        }
        yxbeta[i]=y[i]*X[i,Index[s,]]%*%hatbetai
      }else{
        yxbeta[i]=0
      }
    }
    Yxbeta=sum(yxbeta)
    return(Yxbeta)
  }


  Yxbeta=matrix(nrow = S,ncol=1)
  for(i in 1:S){
    Yxbeta[i]=Yxbetersolver(i)
  }
  rm(i)



  # calcualte model-averaging weight
  solvew_fun_MA<-function(start0){
    ob_fun<-function(w){
      return((sum(exp(X[,1:(p2)]%*%t(Hatbeta)%*%w))-sum(Yxbeta*w)))
    }
    A=matrix(rep(1,S),1,S,byrow = TRUE)
    ret=solnp(start0,ob_fun,eqfun=sum,eqB=c(1),LB=rep(0,S),UB=rep(1,S))
    hatw=ret$par
    return(hatw)
  }


  # calculate KL loss
  KLloss_semi<-function(w){
    #-\frac{1}{n_1}\sum_{i=1}^{n_1} \log\frac{\hat{\mu}^y_{test,i}e^{-\hat{\mu}_i}}{y_i !}
    part1=X%*%t(Hatbeta)%*%w
    klloss_semi=-mean(y*part1-exp(part1)-log(factorial(y)))
    return(klloss_semi)
  }

  # calculate MSE
  MSE<-function(w){
    part1=X%*%t(Hatbeta)%*%w
    return(mean((y-exp(part1))^2))
  }



  # calculate the scores of all methods
  start0=rep(1,S)/S
  hatw=solvew_fun_MA(start0)
  KLlossMA=KLloss_semi(hatw)
  MSEMA=MSE(hatw)


  AICw=rep(0,S)
  AICselection=which.min(Aic)
  AICw[AICselection]=1
  KLlossAIC=KLloss_semi(AICw)
  MSEAIC=MSE(AICw)

  BICw=rep(0,S)
  BICselection=which.min(Bic)
  BICw[BICselection]=1
  KLlossBIC=KLloss_semi(BICw)
  MSEBIC=MSE(BICw)


  Aic2=t(matrix(rep(-Aic,S),ncol=S,byrow=TRUE)+c(Aic))
  SAICw=1/colSums(apply(Aic2/2, 2,exp))
  KLlossSAIC=KLloss_semi(SAICw)
  MSESAIC=MSE(SAICw)

  Bic2=t(matrix(rep(-Bic,S),ncol=S,byrow=TRUE)+c(Bic))
  SBICw=1/colSums(apply(Bic2/2, 2,exp))
  KLlossSBIC=KLloss_semi(SBICw)
  MSESBIC=MSE(SBICw)

  Fullw=rep(0,S)
  Fullw[S]=1
  KLlossFull=KLloss_semi(Fullw)
  MSEFull=MSE(Fullw)


  result=list(Index=Index,
              weight.MA=hatw, weight.SAIC=SAICw, weight.SBIC=SBICw, OptimalModel.AIC=AICselection, OptimalModel.BIC=BICselection,
              MSE.MA=MSEMA, MSE.AIC=MSEAIC, MSE.BIC=MSEBIC, MSE.SAIC=MSESAIC, MSE.SBIC=MSESBIC, MSE.FULL=MSEFull,
              KLloss.MA=KLlossMA,KLloss.AIC=KLlossAIC,KLloss.BIC=KLlossSBIC,KLloss.SAIC=KLlossSAIC,KLloss.SBIC=KLlossSBIC,KLloss.Full=KLlossFull)
  return(result)
}
